---
title: 'NodeJS의 이벤트 루프 이해하기'
type: 'concept'
language: 'Node.js'
tags:
  - Node.js
dateModified: 2025.09.10
---

## 이벤트 루프란?
이벤트 루프(Event Loop)는 Node.js 환경에서 동기 코드와 비동기 코드의 실행을 조정하고 조율하는 디자인 패턴이자 핵심 메커니즘입니다. <br />

## 이벤트 루프가 필요한 이유
JavaScript는 동기적이며 싱글 스레드라는 특징을 가지고 있습니다. <br />
이러한 특징은 파일 읽기, 네트워크 요청, CPU 바운드 작업(계산이 오래 걸리는 작업)을 진행할 때 전체 스레드(메인 스레드)가 멈추는 문제가 발생할 수 있습니다. <br />
이벤트 루프는 이러한 싱글 스레드 환경에서 비동기 작업을 효율적으로 처리할 수 있게 합니다.

## 이벤트 루프의 구현
이벤트 루프는 Node.js 런타임을 구성하는 핵심 외부 종속성 중 하나인 `libuv` 라이브러리를 통해 구현됩니다. <br />
`libuv`는 C로 작성된 크로스 플랫폼 라이브러리로, 비동기 I/O 처리를 지원하며, 이벤트 루프를 구현하여 콜 스택에 어떤 작업을 쌓을지 관장합니다.

## 이벤트 루프의 동작 순서
이벤트 루프의 실행은 동기 코드 실행 > 비동기 작업 위임 > 이벤트 루프 단계별 콜백 처리 순서로 이루어집니다.

1. 이벤트 루프 생성
2. 동기 코드 실행: 생성된 이벤트 루프에 진입하기 전에, 동기 코드가 이벤트 루프 바깥에서 처음부터 끝까지 순차적으로 실행됩니다.
3. 비동기 작업 위임: 동기 코드를 실행하는 동안 `fs.readFile()`나 `setTimeout()` 같은 비동기 함수를 만나면, 해당 작업은 `libuv`에게 위임됩니다.
  - `libuv`는 위임받은 비동기 작업을 처리하기 위해 다음과 같이 결정합니다:
    1. OS 커널 지원 확인: `libuv`는 운영체제 커널이 해당 작업을 네이티브 비동기 메커니즘으로 지원하는지 확인합니다. 네트워크 I/O(예: 데이터베이스 쿼리, HTTP 요청)처럼 지원되는 작업은 커널에게 요청되고, 워커 스레드 풀을 사용하지 않습니다.
    2. 스레드 풀 사용: 커널이 비동기를 지원하지 않거나 시간이 오래 걸리는 작업(블로킹 위험이 있는 작업)은 `libuv`가 관리하는 **워커 스레드 풀(Thread Pool)**에 위임됩니다.
      ◦ 사용되는 작업 예시: 파일 시스템(fs 모듈의 동기 작업 제외), DNS 조회, `crypto.pbkdf2()`와 같은 고비용 암호화 함수, `Zlib` 작업 등이 스레드 풀을 사용합니다.
      ◦ 스레드 풀 크기: `libuv`는 기본적으로 4개의 스레드를 가진 스레드 풀을 생성합니다.
4. 콜 스택 비우기: 동기 코드가 모두 실행되면 콜 스택은 비워집니다.
5. 이벤트 루프의 순환 6단계 (매크로태스크)
  - 동기 코드 실행이 완료되고 콜 스택이 비면, 이벤트 루프는 6개의 **페이즈(Phase)**를 순서대로 방문하며 각 페이즈가 관리하는 매크로태스크 큐의 콜백을 실행합니다.
  - 페이즈에서 페이즈로 넘어가는 것을 `Tick`이라고 합니다.
    1. **Timer Phase (타이머 단계)**: `setTimeout`, `setInterval` 타이머 만료 콜백을 처리합니다. (최소 힙 기반으로 관리됨).
    2. **Pending Callbacks Phase** (보류 중인 콜백 단계): 이전 루프에서 시스템 한도 등으로 인해 처리되지 못한 I/O 콜백이나 일부 시스템 콜백을 처리합니다.
    3. **Idle, Prepare Phase** (유휴, 준비 단계): Node.js 내부 관리를 위한 단계로, JavaScript 코드를 실행하지 않습니다.
    4. **Poll Phase** (폴링 단계)
      - 새로운 I/O 이벤트를 가져오고 콜백을 실행합니다. 파일 I/O 완료, 네트워크 응답 도착 등 대부분의 I/O 콜백이 실행됩니다.
      - 큐가 비어있으면 다음 페이즈로 이동하기 전 일정 시간 대기할 수 있습니다.
    5. **Check Phase** (확인 단계): `setImmediate()` 콜백을 처리합니다.
    6. **Close Callbacks Phase** (콜백 단계 닫기): socket.on('close', ...)와 같은 'close' 이벤트 핸들러를 처리합니다.

## 마이크로태스크 큐
이벤트 루프에 속하지는 않지만, 비동기 실행 순서에서 **마이크로태스크(Microtask)**는 매크로태스크보다 높은 우선순위를 가집니다. <br />
(마이크로태스크 큐는 `libuv`가 아닌 Node.js 런타임 내부에 독립적으로 구현되어 있습니다.) <br />
현재 실행 중인 매크로태스크가 완료된 직후, 이벤트 루프가 다음 단계(Phase)로 넘어가기 전에 완전히 비워집니다.

1. `process.nextTick` Queue (nextTickQueue): 모든 마이크로태스크 중 가장 높은 우선순위를 가집니다.
2. Promise Queue (microTaskQueue): `Promise.then()`, `.catch()`, `.finally()` 콜백을 담고 있으며, `process.nextTick` 다음으로 실행됩니다.

이러한 동작 원리 덕분에 Node.js는 싱글 스레드의 한계를 극복하고 효율적인 비동기 처리를 수행할 수 있습니다.