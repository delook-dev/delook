---
title: 'React에서 메모이제이션으로 성능 최적화하기'
type: 'concept'
language: 'React'
tags:
  - Performance
  - Optimization
  - Memoization
  - Hooks
dateModified: 2025.09.02
---

# 메모이제이션(Memoization)

> 동일한 계산을 반복해야 하는 경우, **이전에 계산한 값**을 메모리에 저장해두었다가 꺼내 쓸 수 있도록 하는 **최적화 기법**입니다.

이는 **캐시(Cache)** 개념과 유사합니다. 함수를 호출할 때 입력-결과 값을 쌍으로 저장하고, 동일한 입력이 들어왔을 때 저장된 결과를 즉시 반환합니다.


## React에서의 메모이제이션
React에서는 렌더링 성능 최적화를 위해 크게 세 가지 기법을 제공합니다.



### 1. React.memo
**컴포넌트 전체**를 메모이제이션하여 props가 변경되지 않으면 리렌더링을 건너뜁니다.
- **주요 목적**: 컴포넌트의 **불필요한 리렌더링**을 방지하여 전체적인 렌더링 성능을 개선합니다.
```typescript
// props가 변경되지 않으면 리렌더링하지 않음
const PetList = React.memo(({ data, type, age }) => {
  return (
    <div>
      {data.map(pet => <PetCard key={pet.id} pet={pet} />)}
    </div>
  );
});
```

#### 언제 사용하면 좋을까?
- 리스트 아이템처럼 렌더링 비용이 큰 컴포넌트가 있을 때
- 부모에서 매번 같은 props를 내려보내는데, 불필요하게 리렌더링되는 경우
- 배열/객체 props가 자주 새로 생성되는 경우에는 equal 함수(커스텀 비교)도 고려 가능


### 2. useMemo
컴포넌트 내부의 **특정 값이나 계산 결과**를 메모이제이션하여 의존성 배열이 변경되지 않으면 재계산을 건너뜁니다.
- **주요 목적**: 복잡한 계산 과정이나 새로운 객체/배열 생성을 방지하여 계산 비용을 절약합니다.
```typescript
function SearchPage({ data, page }) {
  // 페이지네이션 계산 결과를 메모이제이션
  const paginatedData = useMemo(() => {
    const itemsPerPage = 20;
    const start = (page - 1) * itemsPerPage;
    return data.slice(start, start + itemsPerPage);
  }, [data, page]); // data나 page가 변경될 때만 재계산

  const totalPages = useMemo(() => {
    return Math.ceil(data.length / itemsPerPage);
  }, [data]);

  return <PetList data={paginatedData} />;
}
```

#### 언제 사용하면 좋을까?
- 데이터 필터링, 정렬, 페이지네이션처럼 계산 비용이 큰 연산이 반복될 때
- 매 렌더마다 새 배열/객체가 만들어져서 하위 컴포넌트가 불필요하게 리렌더링될 때


### 3. useCallback
**함수의 참조값**을 메모이제이션하여 의존성 배열이 변경되지 않으면 동일한 함수 참조를 유지합니다.
- **주요 목적**: 함수가 props로 전달될 때 **참조값 변경**으로 인한 **불필요한 리렌더링**을 방지합니다.
```typescript
function ParentComponent({ items }) {
  const [filter, setFilter] = useState('');

  // filter가 변경되지 않으면 동일한 함수 참조 유지
  const handleItemClick = useCallback((id) => {
    const filteredItems = items.filter(item => item.name.includes(filter));
    console.log(`Clicked item ${id}`, filteredItems);
  }, [items, filter]);

  return (
    <div>
      {items.map(item => 
        <ItemComponent 
          key={item.id} 
          item={item}
          onClick={handleItemClick} 
        />
      )}
    </div>
  );
}
```

#### 언제 사용하면 좋을까?
- 콜백 함수를 props로 넘기는 경우 (```onClick```, ```onChange``` 등)
- 자식 컴포넌트가 React.memo로 감싸져 있어서 함수 참조가 바뀌면 불필요하게 리렌더링되는 경우


## 정리
- **React.memo**: 렌더링 비용이 큰 컴포넌트, 동일한 props로 자주 호출될 때 사용
- **useMemo**: 계산 비용이 큰 연산(필터링, 정렬, 페이지네이션 등)에 사용
- **useCallback**: 콜백을 자식에게 내려주는데, 참조 변경으로 불필요한 리렌더링이 생길 때

### 사용 시 주의사항
1. **과도한 사용 금지**: 모든 값을 메모이제이션하면 오히려 **메모리 사용량**이 증가할 수 있습니다.
```typescript
// 불필요한 메모이제이션 (권장하지 않음)
const simpleValue = useMemo(() => props.count + 1, [props.count]);
```

2. **의존성 배열 설정**: 의존성 배열을 정확히 설정하지 않는 경우 예상치 못한 버그가 발생할 수 있습니다.
```typescript
// 잘못된 의존성 배열
const result = useMemo(() => {
  return items.filter(item => item.category === selectedCategory);
}, [items]); // selectedCategory를 의존성에 포함하지 않음 (버그 발생)

// 올바른 의존성 배열
const result = useMemo(() => {
  return items.filter(item => item.category === selectedCategory);
}, [items, selectedCategory]);
```


### 참고자료
- [리액트 렌더링 성능 최적화에 대한 고민](https://hoonlog.vercel.app/react-optimize)
- [Web: 최적화와 React.memo, useMemo 알아보기](https://medium.com/hcleedev/web-%EC%B5%9C%EC%A0%81%ED%99%94%EC%99%80-react-memo-usememo-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-4324a237a039)
