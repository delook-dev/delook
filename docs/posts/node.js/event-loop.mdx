---
title: 'Node.js의 이벤트 루프 이해하기'
type: 'concept'
language: 'Node.js'
tags:
  - Node.js
dateModified: 2025.09.21
---

## 이벤트 루프란?
이벤트 루프(Event Loop)는 Node.js 환경에서 동기 코드와 비동기 코드의 실행을 조정하고 조율하는 디자인 패턴이자 핵심 메커니즘입니다. <br />

## 이벤트 루프가 필요한 이유
JavaScript는 동기적이며 싱글 스레드라는 특징을 가지고 있습니다. <br />
이러한 특징은 파일 읽기, 네트워크 요청, CPU 바운드 작업(계산이 오래 걸리는 작업)을 진행할 때 전체 스레드(메인 스레드)가 멈추는 문제가 발생할 수 있습니다. <br />
이벤트 루프는 이러한 싱글 스레드 환경에서 비동기 작업을 효율적으로 처리할 수 있게 합니다.

## 이벤트 루프의 구현
이벤트 루프는 Node.js 런타임을 구성하는 핵심 외부 종속성 중 하나인 `libuv` 라이브러리를 통해 구현됩니다. <br />
`libuv`는 C로 작성된 크로스 플랫폼 라이브러리로, 비동기 I/O 처리를 지원하며, 이벤트 루프를 구현하여 콜 스택에 어떤 작업을 쌓을지 관장합니다.

## 이벤트 루프의 동작 순서
이벤트 루프의 실행은 동기 코드 실행 > 비동기 작업 위임 > 이벤트 루프 단계별 콜백 처리 순서로 이루어집니다.

### 1. 이벤트 루프 생성
### 2. 동기 코드 실행
생성된 이벤트 루프에 진입하기 전에, 동기 코드가 이벤트 루프 바깥에서 처음부터 끝까지 순차적으로 실행됩니다.
### 3. 비동기 작업 위임
동기 코드를 실행하는 동안 `fs.readFile()`나 `setTimeout()` 같은 비동기 함수를 만나면, 해당 작업은 `libuv`에게 위임됩니다. <br/>
`libuv`는 위임받은 비동기 작업을 처리하기 위해 다음과 같이 결정합니다.
  1. OS 커널 지원 확인: `libuv`는 운영체제 커널이 해당 작업을 네이티브 비동기 메커니즘으로 지원하는지 확인합니다. 네트워크 I/O(예: 데이터베이스 쿼리, HTTP 요청)처럼 지원되는 작업은 커널에게 요청하고, 워커 스레드 풀을 사용하지 않습니다.
  2. 스레드 풀 사용: 커널이 비동기를 지원하지 않거나 시간이 오래 걸리는 작업(블로킹 위험이 있는 작업)은 `libuv`가 관리하는 <b>워커 스레드 풀(Thread Pool)</b>에 위임됩니다. <br />
    ◦ 사용되는 작업 예시: 파일 시스템(fs 모듈의 동기 작업 제외), DNS 조회, `crypto.pbkdf2()`와 같은 고비용 암호화 함수, `Zlib` 작업 등이 스레드 풀을 사용합니다.  <br />
    ◦ 스레드 풀 크기: `libuv`는 기본적으로 4개의 스레드를 가진 스레드 풀을 생성합니다. `UV_THREADPOOL_SIZE` 환경변수로 최대 1024개까지 늘릴 수 있습니다. (`libuv` 1.30.0 기준)
### 4. 콜 스택 비우기
동기 코드가 모두 실행되면 콜 스택은 비워집니다.
### 5. 이벤트 루프의 순환 6단계 (매크로태스크)
동기 코드 실행이 완료되고 콜 스택이 비면, 이벤트 루프는 6개의 <b>페이즈(Phase)</b>를 순서대로 방문하며 각 페이즈가 관리하는 매크로태스크 큐의 콜백을 실행합니다.
<br/> (페이즈에서 페이즈로 넘어가는 것을 `Tick`이라고 합니다.)
  1. **Timer Phase (타이머 단계)**: `setTimeout`, `setInterval` 타이머 만료 콜백을 처리합니다.최소 힙 기반으로 관리됩니다.
  2. **Pending Callbacks Phase (보류 중인 콜백 단계)**: 이전 루프에서 시스템 한도 등으로 인해 처리되지 못한 I/O 콜백이나 일부 시스템 콜백을 처리합니다.
  3. **Idle, Prepare Phase (유휴, 준비 단계)**: Node.js 내부 관리를 위한 단계로, JavaScript 코드를 실행하지 않습니다.
  4. **Poll Phase (폴링 단계)** <br />
    ◦ 새로운 I/O 이벤트를 가져오고 콜백을 실행합니다. 파일 I/O 완료, 네트워크 응답 도착 등 대부분의 I/O 콜백이 실행됩니다. <br />
    ◦ 큐가 비어있으면 다음 페이즈로 이동하기 전 일정 시간 대기할 수 있습니다.
  5. **Check Phase (확인 단계)**: `setImmediate()` 콜백을 처리합니다.
  6. **Close Callbacks Phase (종료 콜백 단계)**: `socket.on('close', ...)`와 같은 close 이벤트 핸들러를 처리합니다.

## 마이크로태스크 큐
이벤트 루프에 속하지는 않지만, 비동기 실행 순서에서 <b>마이크로태스크(Microtask)</b>는 매크로태스크보다 높은 우선순위를 가집니다. <br />
(마이크로태스크 큐는 `libuv`가 아닌 Node.js 런타임 내부에 독립적으로 구현되어 있습니다.) <br />
현재 실행 중인 매크로태스크가 완료된 직후, 이벤트 루프가 다음 단계(Phase)로 넘어가기 전에 완전히 비워집니다.

1. `process.nextTick` Queue (nextTickQueue): 모든 마이크로태스크 중 가장 높은 우선순위를 가집니다.
2. Promise Queue (microTaskQueue): `Promise.then()`, `.catch()`, `.finally()` 콜백을 담고 있으며, `process.nextTick` 다음으로 실행됩니다.

이러한 동작 원리 덕분에 Node.js는 싱글 스레드의 한계를 극복하고 효율적인 비동기 처리를 수행할 수 있습니다.