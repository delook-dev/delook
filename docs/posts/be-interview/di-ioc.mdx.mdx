---
title: DI, IoC란 무엇인가요?
type: 'interview'
language: 'BE-Interview'
tags:
  - DI
  - IoC
dateModified: 2025.09.19
---

## 답변

### DI (Dependency Injection)

**의존성 주입**이란 어떤 클래스가 필요로 하는 의존성을 외부에서 주입받는 것을 말합니다.  
Spring에서는 **IoC 컨테이너**가 객체의 생성과 의존성 주입을 담당합니다.

### IoC (Inversion of Control)

**제어의 역전**이란 프로그램의 제어 권한을 개발자가 아닌 프레임워크에 위임하는 것을 말합니다.  
Spring에서 **ApplicationContext**는 BeanFactory를 확장한 IoC 컨테이너 구현체로, Bean의 생성·의존성 주입·생명주기를 관리합니다.

### DI와 IoC의 관계

IoC는 제어권을 역전시키는 설계 원칙이고, DI는 이를 구현하는 구체적인 기법입니다.  
Spring에서는 IoC 컨테이너가 객체 생성 제어권을 가지고, DI를 통해 의존성을 주입하여 IoC 원칙을 실현합니다.

### 왜 중요한가?

1. **결합도 감소**: 클래스 간의 의존성을 줄여 코드의 유연성을 높입니다
2. **테스트 용이성**: Mock 객체를 쉽게 주입하여 단위 테스트가 가능합니다
3. **재사용성 향상**: 의존성을 외부에서 주입받아 다양한 환경에서 재사용 가능합니다
4. **유지보수성**: 변경사항이 다른 클래스에 미치는 영향을 최소화합니다

---

## 전통적인 방식 vs DI 방식

#### 전통적인 방식 (강한 결합)

```java
public class OrderService {
    private EmailService emailService = new EmailService(); // 직접 생성
    private DatabaseService dbService = new MySQLService(); // 구체 클래스에 의존

    public void processOrder(Order order) {
        dbService.save(order);
        emailService.sendConfirmation(order.getEmail());
    }
}
```

#### DI 방식 (느슨한 결합)

```java
public class OrderService {
    private final EmailService emailService;
    private final DatabaseService dbService;

    public OrderService(EmailService emailService, DatabaseService dbService) {
        this.emailService = emailService;
        this.dbService = dbService;
    }

    public void processOrder(Order order) {
        dbService.save(order);
        emailService.sendConfirmation(order.getEmail());
    }
}
```

---

## DI 의존성 주입 방법

#### 1. Field 주입 (필드 주입)

```java
@Component
public class SampleController {
    @Autowired
    private SampleService sampleService; // 필드 주입
}
```

**장점:**

- 코드가 간결함
- 작성이 쉬움

**단점:**

- 테스트하기 어려움 (Reflection 필요)
- 불변 객체 생성 불가능
- 순환 의존성 문제 발견이 어려움
- 의존성이 숨겨져 있어 가독성 떨어짐

#### 2. Setter 주입 (수정자 주입)

```java
@Component
public class SampleController {
    private SampleService sampleService;

    @Autowired
    public void setSampleService(SampleService sampleService) {
        this.sampleService = sampleService;
    }
}
```

**장점:**

- 선택적 의존성에 적합
- 객체 생성 후 의존성 변경 가능

**단점:**

- 불변 객체 생성 불가능
- 의존성이 설정되지 않을 위험
- 런타임에 NullPointerException 발생 가능

#### 3. 생성자 주입 (권장 방식)

```java
@Component
public class SampleController {
    private final SampleService sampleService;

    public SampleController(SampleService sampleService) {
        this.sampleService = sampleService;
    }
}
```

**장점:**

- 불변 객체 생성 가능 (final 키워드)
- 테스트하기 쉬움
- 순환 의존성 조기 발견
- 필수 의존성 보장
- 의존성이 명확히 드러남

**단점:**

- 생성자 매개변수가 많아질 수 있음 (이는 설계 문제의 신호일 수 있음)

---

## IoC 제어의 역전 예시

#### 전통적인 방식 - 개발자가 제어

```java
public class Application {
    public static void main(String[] args) {
        UserService userService = new UserService();
        userService.createUser("John");
    }
}
```

#### IoC 방식 - 프레임워크가 제어

```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args); // Spring이 제어권을 가짐
    }
}
```

Spring에서는 컴포넌트 스캔을 통해 `@Component` 계열 어노테이션이 붙은 클래스들을 자동으로 Bean으로 등록하고,
ApplicationContext(BeanFactory 구현체)가 Bean들 간의 의존성을 자동으로 주입합니다.
