---
title: 시간복잡도와 공간복잡도 (Big O notation)
type: 'concept'
language: 'CS'
tags:
  - Algorithm
dateModified: 2025.09.07
---

# 시간복잡도와 공간복잡도 (Big O notation)

알고리즘의 성능을 분석하는 데 사용되는 수학적 표기법으로, 입력 크기에 따른 실행 시간(시간복잡도)과 메모리 사용량(공간복잡도)의 증가율을 나타냅니다.

Big O 표기법은 최악의 경우(worst case)를 기준으로 하며, 알고리즘의 효율성을 객관적으로 비교할 수 있게 해줍니다.

## 시간복잡도 (Time Complexity)

입력 크기 n에 따라 알고리즘의 실행 시간이 어떻게 증가하는지를 나타냅니다.

### O(1) - 상수 시간

입력 크기에 관계없이 항상 일정한 시간이 소요되는 알고리즘입니다.

#### 예시

```javascript
function getFirstElement(arr) {
  return arr[0]; // 배열의 크기와 관계없이 항상 동일한 시간
}

const numbers = [1, 2, 3, 4, 5];
console.log(getFirstElement(numbers)); // 1
```

### O(log n) - 로그 시간

입력 크기가 증가할 때마다 실행 시간이 로그적으로 증가하는 알고리즘입니다. 주로 이진 탐색에서 나타납니다.

#### 예시

```javascript
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return -1;
}

const sortedNumbers = [1, 3, 5, 7, 9, 11, 13];
console.log(binarySearch(sortedNumbers, 7)); // 3
```

### O(n) - 선형 시간

입력 크기에 비례하여 실행 시간이 증가하는 알고리즘입니다.

#### 예시

```javascript
function findMax(arr) {
  let max = arr[0];
  
  // 배열의 모든 요소를 한 번씩 확인
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
  }
  
  return max;
}

const numbers = [3, 7, 2, 9, 1];
console.log(findMax(numbers)); // 9
```

### O(n²) - 제곱 시간

입력 크기의 제곱에 비례하여 실행 시간이 증가하는 알고리즘입니다. 주로 중첩된 반복문에서 나타납니다.

#### 예시

```javascript
function bubbleSort(arr) {
  const n = arr.length;
  
  // 이중 반복문으로 인해 O(n²)
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        // 요소 교환
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  
  return arr;
}

const numbers = [64, 34, 25, 12, 22, 11, 90];
console.log(bubbleSort([...numbers])); // [11, 12, 22, 25, 34, 64, 90]
```

## 공간복잡도 (Space Complexity)

입력 크기 n에 따라 알고리즘이 사용하는 메모리 공간이 어떻게 증가하는지를 나타냅니다.

### O(1) - 상수 공간

입력 크기에 관계없이 항상 일정한 메모리를 사용하는 알고리즘입니다.

#### 예시

```javascript
function swap(arr, i, j) {
  // 임시 변수 하나만 사용 (상수 공간)
  const temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}
```

### O(n) - 선형 공간

입력 크기에 비례하여 메모리를 사용하는 알고리즘입니다.

#### 예시

```javascript
function createCopy(arr) {
  // 입력 배열과 같은 크기의 새 배열 생성
  const copy = [];
  
  for (let i = 0; i < arr.length; i++) {
    copy[i] = arr[i];
  }
  
  return copy; // O(n) 공간 사용
}
```

## 복잡도 비교

입력 크기가 1000일 때의 대략적인 연산 횟수:

| 복잡도 | 연산 횟수 | 예시 |
|--------|-----------|------|
| O(1) | 1 | 배열 인덱스 접근 |
| O(log n) | 10 | 이진 탐색 |
| O(n) | 1,000 | 선형 탐색 |
| O(n log n) | 10,000 | 합병 정렬 |
| O(n²) | 1,000,000 | 버블 정렬 |

## 실무에서의 활용

### 프론트엔드 성능 최적화

```javascript
// 비효율적: O(n²) - 중첩 반복문
function findDuplicates(arr) {
  const duplicates = [];
  
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] === arr[j] && !duplicates.includes(arr[i])) {
        duplicates.push(arr[i]);
      }
    }
  }
  
  return duplicates;
}

// 효율적: O(n) - Set 자료구조 활용
function findDuplicatesOptimized(arr) {
  const seen = new Set();
  const duplicates = new Set();
  
  for (const item of arr) {
    if (seen.has(item)) {
      duplicates.add(item);
    } else {
      seen.add(item);
    }
  }
  
  return Array.from(duplicates);
}
```

### API 응답 처리 최적화

```javascript
// 비효율적: O(n²) - 중첩 검색
function mergeUserData(users, profiles) {
  return users.map(user => ({
    ...user,
    profile: profiles.find(profile => profile.userId === user.id)
  }));
}

// 효율적: O(n) - Map을 활용한 해시 테이블
function mergeUserDataOptimized(users, profiles) {
  const profileMap = new Map(
    profiles.map(profile => [profile.userId, profile])
  );
  
  return users.map(user => ({
    ...user,
    profile: profileMap.get(user.id)
  }));
}
```

Big O 표기법을 이해하면 코드의 성능을 예측하고, 더 효율적인 알고리즘을 선택할 수 있습니다. 특히 대용량 데이터를 다루는 웹 애플리케이션에서는 이러한 지식이 사용자 경험에 직접적인 영향을 미칩니다.
