---
title: '자바스크립트의 sort 동작원리와 정렬 알고리즘'
type: 'concept'
language: 'javascript'
tags:
  - javascript
  - Array.prototype.sort
  - Tim sort
dateModified: 2025.09.21
---

### Array.prototype.sort
- 자바스크립트의 sort는 다음과 같이 사용할 수 있습니다.
```js
type Sort = function (compareFunction?: (a: any, b: any) => number) {
    ...
    // 내부 sort 알고리즘으로 this 배열을 정렬
}

[1, 5, 3, 2, 4].sort((a, b) => a - b); // [1, 2, 3, 4, 5]
[1, 2, 3, 11, 12].sort() // [1, 11, 12, 2, 3]
```
- 비교 함수는 선택 인자입니다. 비교 함수를 넣지 않는 경우에 sort는 다음과 같이 동작합니다.
  - 배열 원소를 ASCII 문자 기준으로 오름차순 정렬
  - 정렬을 실행하기 전에 각 원소를 문자열로 형변환
  - 문자열로 형변환 된 이후에는 맨 앞의 숫자만 비교하게 되므로 1로 시작하는 수들이 앞으로 정렬됨


----

### CompareFunction은 어떻게 동작하나요?

- CompareFunction을 선언하면 sort() 함수는 CompareFunction에게 배열의 요소를 2개씩 반복해서 보낸 뒤, CompareFunction이 반환하는 값을 기준으로 정렬을 합니다.

```md
returnValue < 0 : a가 b보다 앞에 있어야 한다.
returnValue === 0 : a와 b의 순서를 바꾸지 않는다.
returnValue > 0 : b가 a보다 앞에 와야 한다.
```

```js
const arr = [3, 4, 5, 2, 1]
// 오름차순
arr.sort((a,b) => a - b) // [1, 2, 3, 4, 5]

// 내림차순
arr.sort((a,b) => b - a) // [5, 4, 3, 2, 1]
```

---

### Chrome V8 엔진은 어떤 알고리즘을 사용해서 sort를 하나요?

- Tim Sort 정렬 알고리즘 사용합니다.
- Tim sort 알고리즘은 Insertion Sort와 Merge Sort를 결합한 알고리즘
    - 최선의 시간 복잡도 O(n), 평균 및 최악의 경우 시간 복잡도 O(nlogN)
    - 안정적인 두 정렬 방법을 결합했기 때문에 안정적 
    - 기존의 Merge Sort에 비해 적은 추가 메모리를 사용하여 다른 O(nlogN) 정렬 알고리즘의 단점 극복

----

### Tim Sort

1. 기본 아이디어
	-	Merge Sort: 안정적이고 O(n log n)이지만 작은 배열에서는 느릴 수 있음.
	-	Insertion Sort: O(n²)이지만 작은 배열에서는 상수항이 작고 빠름.

> 👉 Tim Sort = Insertion Sort + Merge Sort 작은 덩어리는 Insertion Sort로, 
> 큰 덩어리는 Merge Sort로 병합해 최적 성능을 얻는 하이브리드 정렬


2. Run (런)
	-	배열을 훑으면서 증가하거나 감소하는 부분 배열을 찾아 run이라 부름
	-	감소하는 run은 뒤집어서 모두 증가 run으로 만듦
	-	작은 run은 Binary Insertion Sort로 정렬해 줌
	-	이렇게 하면 이미 정렬돼 있는 데이터(실생활에서 자주 있음)를 크게 한 번에 묶을 수 있음 → 최선의 경우 O(n)


3. Merge (병합)
	-	만들어진 run들을 병합하면서 전체 배열을 정렬
	-	단, run 크기가 제각각이라 비효율적일 수 있음 → 스택에 run을 쌓고 규칙에 따라 합치기
	-	규칙을 지키면:
	-	스택 크기가 제한되어 관리가 쉬움 (피보나치 수열처럼 커짐)
	-	비슷한 크기의 run끼리 병합 → 효율적


4. 최적화 포인트
	-	minrun: run의 최소 길이를 정해서, 너무 작은 run은 Insertion Sort로 정렬 후 병합 (보통 32~64)
	-	Binary Insertion Sort: 삽입 위치를 이분 탐색으로 찾아서 비교 횟수를 줄임
	-	Galloping Mode: 병합할 때 한쪽 run의 원소가 많이 연속으로 나올 경우 “점프”로 복사해서 속도 향상


5. 시간 복잡도
	-	최선: O(n) (이미 정렬된 경우 run이 하나만 생성됨)
	-	평균/최악: O(n log n)
	-	공간 복잡도: O(n) (Merge Sort처럼 추가 메모리 필요하나 최대 n/2만 사용해서 최적화)