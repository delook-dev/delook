---
title: this 바인딩
type: 'concept'
language: Javascript
tags:
  - Javascript
dateModified: 2025.09.14
---

# this
`this`는 함수를 호출한 주체 자신을 가리키는 참조값입니다. <br />
javaScript의 `this`는 다른 언어와 다르게 동작합니다. `this`는 함수가 정의된 시점이 아니라, 호출된 방식에 의해 결정됩니다. <br />
또한, 엄격모드(strict mode)와 비엄격모드(non-strict mode)에서도 차이가 있습니다.

## 전역 컨텍스트에서의 this
전역 컨텍스트에서 `this`는 엄격모드에 상관 없이 전역 객체(브라우저에서는 `window`, NodeJS에서는 `global`)을 가리킵니다.

```js
console.log(this) // window (또는 global)
```

## 일반 함수로 호출 시 
전역 컨텍스트에서 일반 함수를 호출하는 경우 `this` 값은 엄격모드 여부에 따라 달라집니다.
```js
function callThis() {
    console.log(this)
}

callThis() 
// undefined (엄격모드)
// window (또는 global) (비엄격모드)
```

엄격모드는 ES5(2009)에 도입된 규칙으로, this가 전역 객체를 반환하는 경우 개발자가 실수로 전역 객체를 오염시키는 경우를 방지하기 위하여 도입되었습니다. <br />
엄격모드에서 일반 함수를 호출하는 경우 `this` 값은 `undefined`이 반환되므로, `this` 값의 속성을 접근하려고 하면 런타임 에러가 발생합니다. 이를 통해 버그를 미연에 방지할 수 있습니다.

## 객체 리터럴에서 메서드로 호출 시
함수가 객체의 메서드로 호출될 때, `this`는 해당 메서드를 호출한 객체를 가리킵니다.
```js
const person = {
  name: "minzunim",
  sayHello: function() {
    console.log(this.name);
  }
};

person.sayHello(); // minzunim
```

따라서 같은 함수가 다른 객체에서 호출되는 경우 `this` 값은 호출한 객체에 따라 동적으로 결정됩니다.
```js
function showName() {
  console.log(this.name);
}

const person1 = { name: "minzunim", say: showName };
const person2 = { name: "delook", say: showName };

person1.say(); // "minzunim"
person2.say(); // "delook"
```

## 생성자 함수로 호출 시
생성자 함수(new)로 객체를 생성할 때 `this` 값은 새로운 인스턴스로 고정됩니다.
```js
function Person(name) {
  this.name = name;         
  console.log(this);       
}

const person1 = new Person("minzunim");
console.log(person1.name); // "minzunim"
```

## this의 동적 바인딩이 문제가 되는 상황

1. 함수를 변수에 따로 빼서 호출할 때
    특정 객체의 함수를 변수에 할당해 전역 컨텍스트에서 호출하는 경우 `this` 값은 해당 객체가 아닌 전역 객체 또는 `undefined`가 반환될 수 있습니다.
    ```js
    const person = {
    name: "minzunim",
    sayHello() { console.log(this.name); }
    };

    const f = person.sayHello;
    f(); 
    // 비엄격: window.name (브라우저), undefined (NodeJS)
    // 엄격: undefined
    ```

2. 콜백 함수에서의 this
    콜백 함수가 실행될 때는 독립적인 함수가 호출되는 것과 동일하므로, `this`가 해당 객체를 참조하지 않습니다. <br />
    ```js
    const person = {
    name: "minzunim",
    sayLater() {
        setTimeout(function() {
        console.log(this.name);
        }, 1000);
    }
    };

    person.sayLater(); 
    // 비엄격: window.name (브라우저), Timeout 객체 (NodeJS)
    // 엄격: undefined (브라우저), undefined (NodeJS)
    ```

## this를 명시적으로 바인딩하는 방법 
`call()`, `apply()`, `bind()` 메서드를 사용하면 `this`를 명시적으로 바인딩할 수 있습니다.
```js
function sayHello(age) {
  console.log(this.name, age);
}

const person1 = { name: "minzunim" };
const person2 = { name: "delook" };
```

```js
// call - this 값, 인자를 전달
sayHello.call(person1, 15); // "minzunim 15"
sayHello.call(person2, 1); // "delook 1"

// apply - this 값, 인자를 배열로 전달
sayHello.apply(person1, [15]); // "minzunim 15"
sayHello.apply(person2, [1]); // "delook 1"

// bind - this 값, 인자를 전달한 함수를 변수에 할당하고 필요할 때 호출
const f = sayHello.bind(person1, 15);
f(); // "minzunim 15"
```

## 화살표 함수에서의 this
화살표 함수에서 `this`는 호출되는 방식이 아니라, 함수가 정의될 때의 상위 스코프를 기억하여 참조합니다. <br />
따라서 콜백 함수에서 화살표 함수를 사용하는 경우 함수가 선언된 시점에 소속된 객체를 `this`로 결정합니다.
```js
const person = {
  name: "minzunim",
  sayLater: function() {
    setTimeout(() => {
      console.log(this.name); // "minzunim"
    }, 1000);
  }
};

person.sayLater();
```

하지만 화살표 함수는 항상 선언된 시점의 상위 스코프를 `this`로 참조하기 때문에 경우에 따라 `undefined`를 반환하기도 합니다.
```js
const obj = {
  value: 10,
  show: () => {
    console.log(this.value); // undefined (obj가 아님, 상위 스코프 this)
  }
};
obj.show();
```

## 결론
Javascript에서의 `this`는 동적으로 바인딩되므로 상황에 따라 다르게 쓰는 주의가 필요합니다.