---
title: '인덱스(Index)'
type: 'concept'
language: 'Database'
tags:
  - Database
  - Index
  - SQL
dateModified: 2025.09.06
---

import { ImageContainer } from '/src/components/ui/ImageContainer.tsx';

# 인덱스(Index) 

## 1. 인덱스란?
인덱스(Index)는 데이터베이스에서 검색 성능을 향상시키기 위한 자료구조입니다.
일반적으로 테이블의 특정 칼럼을 기반으로 데이터를 빠르게 탐색할 수 있도록 별도의 구조로 관리됩니다.

- 테이블과는 별도로 존재하며, 정렬된 구조를 유지하여 검색을 최적화합니다.
- 칼럼 값과 물리적 주소를 (Key, Value) 형태로 저장하여 검색 속도를 높입니다.

ex) users 테이블에서 이메일로 검색할 때 이메일 칼럼에 인덱스를 생성하면, 전체 데이터를 탐색하지 않고도 빠르게 사용자를 찾을 수 있습니다.

## 2. 인덱스의 장단점

### 장점
- 검색 속도 향상: 테이블 전체를 검색하는 것보다 빠르게 데이터를 조회할 수 있습니다.
- 정렬 및 그룹화 최적화 : ORDER BY, GROUP BY와 같은 연산의 성능이 개선됩니다.
- JOIN 성능 최적화: 테이블 간 조인 연산 시 인덱스를 활용하여 효율적인 검색이 가능합니다.
- 데이터 무결성 보장 : UNIQUE INDEX는 중복 입력을 방지하여 무결성을 보장합니다.

### 단점
- 추가 저장 공간 필요 : 인덱스 데이터를 저장하기 위해 추가적인 공간이 필요합니다.
- 데이터 변경 시(쓰기 연산) 오버헤드 발생 :  
  - `INSERT`: 새로운 데이터를 삽입 시 인덱스가 함께 갱신됩니다.
  - `DELETE`: 데이터 삭제 시 인덱스에서 해당 항목도 제거됩니다.
  - `UPDATE`: 인덱스가 걸린 컬럼의 값이 변경되면 인덱스를 재구성해야 합니다.
- 과도한 인덱스 사용 시 성능 저하 : 불필요한 인덱스가 많아지면 데이터 변경 작업(쓰기 연산)의 비용이 증가합니다.

## 3. 인덱스의 자료구조

### 1) B+Tree (Balanced Plus Tree)
대부분의 관계형 데이터베이스(RDBMS)에서 사용하는 대표적인 인덱스 구조입니다.
- 데이터를 정렬된 상태로 저장하여 검색, 삽입, 삭제가 빠르게 수행됩니다.
- 리프 노드(Leaf Node)들끼리 Linked List 형태로 연결되어 있어 범위 검색(`BETWEEN`, `ORDER BY`)에 효과적입니다.
- 이진 탐색(Binary Search) 방식으로 동작하며, 평균 탐색 시간은 O(log N) 입니다.

```sql
CREATE INDEX idx_user_name ON users(name);
```
위 코드는 users 테이블의 name 컬럼에 인덱스를 생성하여 검색 성능을 높이는 방법입니다.

### 2) Hash Index (해시 인덱스)

Hash Index는 Key-Value 형태로 저장되며, 특정 키에 대해 빠르게 값을 찾을 수 있는 인덱스 구조입니다.

- `=` 연산(정확한 값 일치 검색)에 최적화되어 있으며, 빠른 검색 속도를 제공합니다.
- 그러나 데이터가 정렬되지 않기 때문에, 부등호(`<`, `>`, `BETWEEN`)와 같은 범위 검색에는 사용할 수 없습니다.

## 4. 클러스터드 인덱스 vs. 비클러스터드 인덱스

### 인덱스 유형 비교

| 인덱스 유형 | 설명 |
|------------|--------------------------------------------------|
| 클러스터드 인덱스 (Clustered Index) | 데이터를 정렬된 상태로 저장하며, 테이블 자체가 인덱스 역할을 합니다. |
| 비클러스터드 인덱스 (Non-Clustered Index) | 실제 데이터와 별도로 인덱스 테이블을 유지하며, 물리적 데이터 주소를 저장힙니다. |

### 클러스터드 인덱스 특징
- 한 테이블당 하나만 생성할 수 있습니다.
- 테이블의 데이터 자체가 물리적으로 정렬된 상태로 저장됩니다.
- 검색 속도가 빠르지만, 삽입(INSERT)·삭제(DELETE) 시 데이터 재정렬이 필요하여 성능이 저하될 수 있습니다.

### 비클러스터드 인덱스 특징
- 한 테이블에 여러 개 생성할 수 있습니다.
- 실제 데이터와 별도로 인덱스 테이블을 유지하며, 물리적 데이터 주소(실제 데이터의 위치)를 가리킵니다.
- 데이터 저장 순서와 무관하며, 검색 시 한 단계를 더 거쳐야 하므로 속도가 다소 느릴 수 있습니다. 

### 클러스터드 인덱스 vs. 비클러스터드 인덱스 예제

```sql
-- 클러스터드 인덱스 (기본키에 자동 생성됨)
CREATE TABLE users (
    id INT PRIMARY KEY,  -- 자동으로 클러스터드 인덱스 적용
    name VARCHAR(50)
);
```

```sql
-- 비클러스터드 인덱스 생성
CREATE INDEX idx_name ON users(name);
```
위 코드에서
- id 컬럼은 PRIMARY KEY로 설정되어 자동으로 클러스터드 인덱스가 생성됩니다.
- name 컬럼에는 비클러스터드 인덱스가 별도로 생성되어, 검색 성능을 향상시킬 수 있습니다.

## 5. 인덱스와 성능 최적화

### 인덱스를 사용할 때 고려해야 할 점
- `WHERE` 절에 자주 사용되는 칼럼에 인덱스를 생성합니다.
- `ORDER BY`, `GROUP BY` 연산이 자주 발생하는 칼럼은 인덱스를 두는 것이 유리합니다.
- `JOIN`에 사용되는 외래키(Foreign Key) 컬럼에 인덱스를 생성하면 조인 연산의 성능을 개선할 수 있습니다.
- 너무 많은 인덱스를 생성하면 쓰기(INSERT, UPDATE, DELETE) 성능이 저하될 수 있으므로 주의해야 한합니다.

## 6. 인덱스 업데이트 및 정리

MySQL(InnoDB)에서는 인덱스 업데이트와 정리를 자동으로 관리합니다.
- 변경 버퍼(Change Buffer)를 사용하여 인덱스 갱신을 지연 처리하고, 이후 병합하여 성능을 최적화합니다.
- MVCC와 Undo Logs를 통해 데이터 버전을 관리하며, 필요 없는 데이터는 Purge 작업으로 정리됩니다.
- 백그라운드 스레드가 자동으로 정리와 병합 작업을 수행하므로 일반적으로 추가 관리가 필요하지 않습니다.

수동 최적화 방법
- OPTIMIZE TABLE 테이블명; 명령어를 실행하면 테이블을 최적화하고 인덱스를 재구성하여 단편화를 줄일 수 있습니다.

## 7. 결론

- 인덱스는 검색 성능을 최적화하는 핵심적인 기능이지만, 삽입(INSERT)·삭제(DELETE)·수정(UPDATE) 시 오버헤드가 발생할 수 있습니다.
- 불필요한 인덱스가 많아지면 데이터 변경(쓰기) 작업의 성능이 저하될 수 있습니다.
- 따라서 읽기(조회) 성능과 쓰기(삽입·수정·삭제) 성능을 균형 있게 조절하는 전략이 필요합니다.
