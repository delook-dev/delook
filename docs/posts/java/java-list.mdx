---
title: ArrayList와 LinkedList의 차이점 비교
type: 'concept'
language: Java
tags:
  - Java
dateModified: 2025.09.22
---

# ArrayList와 LinkedList의 차이점 비교

## 내부 구조
- ArrayList: 연속된 **배열**에 원소 참조값을 저장합니다.
  - 인덱스로 바로 접근 가능(O(1))하며, 배열의 크기가 모자라면 확장(reallocate + copy)합니다.
- LinkedList: **이중 연결 리스트**로, prev/next 포인터로 노드를 연결합니다.
  - 인덱스로 접근 시 리스트의 앞이나 뒤에서 접근(O(n))해야 합니다. 대신 양 끝의 삽입과 삭제는 O(1)을 보장합니다.
 
## 시간 복잡도 비교
| 연산(대표 메서드)                    |           ArrayList 평균 / 최악 |  LinkedList 평균 / 최악 | 설명                                                         |
| ----------------------------- | --------------------------: | ------------------: | ----------------------------------------------------------------- |
| **인덱스 조회** `get(i)`, `set(i)` |             **O(1) / O(1)** |     **O(n) / O(n)** | AL: **배열 기반**이라 임의 접근 가능<br/>LL: **앞/뒤에서 걸어가야** 해서 선형               |
| **끝에 추가** `add(e)`            | **Amortized O(1)** / O(n)\* |     **O(1) / O(1)** | AL: 가끔 **리사이즈(배열 복사)** 때문에 최악 O(n)\*; <br/>LL: tail 포인터로 addLast O(1) |
| **앞에 추가** `add(0,e)`          |             **O(n) / O(n)** |     **O(1) / O(1)** | AL: 모든 원소를 **우측으로 shift**<br/> LL: head 앞에 노드만 연결                    |
| **중간에 삽입** `add(i,e)`         |             **O(n) / O(n)** |     **O(n) / O(n)** | AL: 뒤 요소 **shift** 비용<br/> LL: **위치 찾는 데 O(n)** + 연결 자체 O(1)         |
| **인덱스로 삭제** `remove(i)`       |             **O(n) / O(n)** |     **O(n) / O(n)** | AL: 뒤 요소 **좌측 shift**<br/> LL: **위치 찾기 O(n)** + unlink O(1)          |
| **값으로 삭제** `remove(obj)`      |             **O(n) / O(n)** |     **O(n) / O(n)** | 둘 다 찾는 데 선형 탐색 필요 (동등성 비교 비용 포함)                                 |
| **앞에서 삭제** `removeFirst()`    |             **O(n) / O(n)** |     **O(1) / O(1)** | AL: 전체 shift<br/> LL: head unlink                                    |
| **끝에서 삭제** `remove(size-1)`   |             **O(1) / O(1)** |     **O(1) / O(1)** | 두 구조 모두 꼬리에서 제거는 싸다(LL은 tail, AL은 size만 감소)                      |
| **contains / indexOf**        |             **O(n) / O(n)** |     **O(n) / O(n)** | 선형 탐색 (정렬 유지+이분탐색은 AL만 현실적)                                      |
| **전체 순회** `for/iter`          |             **O(n)** (빠른 편) |     **O(n)** (느릴 수 있음) | AL: **캐시 지역성** 좋아서 실제 체감 빠름<br/> LL: 포인터 chasing으로 느려질 수 있음          |
| **정렬** `Collections.sort`     |              **O(n log n)** |      **O(n log n)** | 구현상 AL이 보통 **상수 비용** 유리(랜덤 액세스/캐시 친화).                            |
| **메모리 사용량**                   |            **O(n)** (참조 배열) | **O(n)** (노드\*3포인터) | LL은 각 노드에 **prev/next 오버헤드 + 객체 헤더** → 메모리/GC 부담 큼.               |
 
## 메모리/CPU 특성
- ArrayList
  - 장점: 원소 참조값을 배열에 연속적으로 저장하므로 CPU 캐시 적중률이 높으며, 순회/정렬/검색이 빠릅니다.
  - 단점: 리스트의 크기를 초과해서 원소를 추가할 때 배열 복사가 발생합니다. (1.5배 크기의 배열을 재할당하며, 기존 원소를 복사합니다.) 맨 앞이나 중간에 삽입/삭제 시, 대량 이동(shift)이 발생합니다.
- LinkedList
  - 장점: 노드의 연결만 바꾸면 되므로, 양 끝 삽입이나 삭제가 O(1)을 보장합니다. 이터레이터로 **중간 수정**이 잦은 경우 효율성이 ArrayList보다 좋습니다.
  - 단점: 각 노드가 객체 + prev포인터 + next포인터의 구조를 가지므로 메모리 오버헤드가 크고, GC 부담이 증가합니다. 또한 포인터 추적으로 인해 캐시 효율이 떨어져, 순회가 ArrayList보다 느립니다.
     - 참고) 포인터 추적이란? ***현재 노드 로드 -> 그 안의 next 포인터 확인 -> 다음 노드 로드***의 의존 체인을 말합니다.
## 언제, 어떤 자료구조를 선택하는 게 좋을까?
- ArrayList를 기본값으로 생각하며, LinkedList를 특수한 경우에 사용합니다.
  - ArrayList는 인덱스 접근/정렬/대량 순회 중심의 구조에서 좋은 효율을 보입니다.
  - LinkedList는 ListIterator로 현재 지점을 잡고 중간에 많은 삽입/삭제를 반복하는 등, 특수한 경우에 사용합니다. 
  
## 정리
- 대부분의 경우에서는 ArrayList가 더 빠르고 메모리 측면에서 효율적입니다.
- 양 끝 삽입/삭제가 매우 많거나, 이터레이터로 중간 지점을 계속 수정한다면, 그때만 LinkedList를 고려합니다.
- Queue/Deque 용도로는 ArrayDeque를 고려합니다.
